Υλοποίηση Συστημάτων Βάσεων Δεδομένων - Εργασία 2


Πληροφορίες για την ομάδα:
	1. Παπαδοπούλου Μαρία-Μαλαματή (sdi2200134)
	2. Τσιμπουράκης Παυλάκος Νεκτάριος (sdi2200196)


Πληροφορίες για τη μεθοδολογία της B+_insert και γενικά για την εργασία:

Τα structs που χρησιμοποιήθηκαν είναι:

	typedef struct {
  	   int height;
  	   int root_block;
	   int num_blocks; 
	} BPLUS_INFO;
Το οποίο περιέχει τα μεταδεδομένα του BPLUS αρχείου. Συγκεκριμένα, θεωρήσαμε σημαντικό να καταχωρηθούν το ύψος
του Β+ δένδρου για να γίνεται ευκολότερα η αναζήτηση στα μπλοκ ευρετηρίου, το id της ρίζας του Β+ δένδρου
και το πλήθος των μπλοκ είτε ευρετηρίου είτε δεδομένων για το BPLUS αρχείο.

	typedef struct {
 	    int records_in_use;
  	    int num_records;
 	    int next_block;
 	    int block_id;
	} BPLUS_DATA_NODE;
Το οποίο περιέχει τα μεταδεδομένα ενός μπλοκ Δεδομένων. Συγκεκριμένα, θεωρήσαμε σημαντικό να καταχωρηθούν το πλήθος
των εγγραφών του συγκεκριμένου μπλοκ, το μέγιστο πλήθος εγγραφών που χωράει ένα μπλοκ δεδομένων, τον δείκτη στο επόμενο
μπλοκ δεδομένων και το id του συγκεκριμένου μπλοκ δεδομένων.

	typedef struct {
 	    int keys_in_use;
 	    int block_id;
	    int block_parent_id;
	} BPLUS_INDEX_NODE;
Το οποίο περιέχει τα μεταδεδομένα ενός μπλοκ Ευρετηρίου. Συγκεκριμένα, θεωρήσαμε σημαντικό να καταχωρηθούν το πλήθος
των κλειδιών του συγκεκριμένου μπλοκ ευρετηρίου, το id του συγκεκριμένου μπλοκ ευρετηρίου και το id του γονιού του
συγκεκριμένου μπλοκ ευρετηρίου.

Επιπρόσθετα, υλοποιήθηκαν και κάποιες βοηθητικές συναρτήσεις στα αρχεία datanode.c και indexnode.c
datanode.c:
BPLUS_DATA_NODE BP_DATA_NODE_CREATE(int blockId): Συνάρτηση, η οποία αρχικοποιεί τα μεταδεδομένα ενός άδειου μπλοκ δεδομένων θέτοντας του το id του ίσο με blockId
void INSERT_AND_SORT(BF_Block *datanode, BPLUS_DATA_NODE* metadata, Record record): Συνάρτηση, η οποία δέχεται ως όρισμα το μπλοκ δεδομένων που θα 
γίνει η εισαγωγή, τα μεταδεδομένα του, που θα μεταβληθούν μετά την εισαγωγή, και την εγγραφή και πραγματοποιεί την εισαγωγή της εγγραφής
διατηρώντας την ταξινόμηση των κλειδιών.

indexnode.c:
BPLUS_INDEX_NODE BP_INDEX_NODE_CREATE(int blockId): Συνάρτηση, η οποία αρχικοποιεί τα μεταδεδομένα ενός άδειου μπλοκ ευρετηρίου θέτοντας του το id του ίσο με blockId
void insert_and_sort_index(BF_Block* indexnode, BPLUS_INDEX_NODE *metadata, int key, int pointer): Συνάρτηση, η οποία δέχεται ως όρισμα το μπλοκ ευρετηρίου που θα 
γίνει η εισαγωγή, τα μεταδεδομένα του, που θα μεταβληθούν μετά την εισαγωγή, το κλειδί και τον δείκτη και πραγματοποιεί την εισαγωγή του κλειδιού
και του δείκτη διατηρώντας την ταξινόμηση των κλειδιών.

Μεθοδολογία που ακολουθήθηκε στην Insert.

B+_insert () {
    Case 1 : Εάν το Β+ δένδρο είναι άδειο
        Step 1 : Δημιουργείται ένα μπλοκ ευρετηρίου, το οποίο ορίζεται ως ρίζα και δημιουργούνται 2 μπλοκ δεδομένων,
		 ένα από τα αριστερά του κλειδιού κι ένα από τα δεξιά του
    Case 2 : Εάν το Β+ δένδρο δεν είναι άδειο
        Step 1 : Traverse το Β+δένδρο για να βρούμε το σωστό μπλοκ δεδομένων, που πρέπει να γίνει η εισαγωγή
        Step 2 : Εισαγωγή
        Case 2.1 : Εάν το μπλοκ δεδομένων έχει χώρο
        Case 2.2 : Εάν το μπλοκ δεδομένων δεν έχει χώρο
            Step 1 : Split το μπλοκ δεδομένων
            Case 2.2.1 : Εάν το μπλοκ ευρετηρίου(γονέας του μπλοκ δεδομένων) έχει χώρο
            Case 2.2.2 : Εάν το μπλοκ ευρετηρίου(γονέας του μπλοκ δεδομένων) δεν έχει χώρο
                Step 1 : Split το μπλοκ ευρετηρίου
                Step 2 : Επανάληψη του προηγούμενου βήματος μέχρι να βρεθεί μπλοκ ευρετηρίου με χώρο ή να φτάσει στην ρίζα

                Special Case : Η ρίζα του Β+δένδρου δεν έχει χώρο
                Step 1 : Split της ρίζας
                Step 2 : Δημιουργία νέας ρίζας
}

Παραδοχές:
1. Όταν πραγματοποιείται διαχωρισμός (split) ενός μπλοκ δεδομένων ή ευρετηρίου, οι εγγραφές ή τα κλειδιά κατανέμονται ισομερώς μεταξύ του παλιού και του
νέου μπλοκ, διατηρώντας πάντα τη σειρά ταξινόμησης. Συγκεκριμένα, οι μισές μεγαλύτερες εγγραφές ή κλειδιά μεταφέρονται στο νέο μπλοκ, ενώ
οι μισές μικρότερες παραμένουν στο παλιό μπλοκ.
2. Ορίσαμε ως global μεταβλητή το int num_keys, το οποίο αντιστοιχεί στο μέγιστο πλήθος κλειδιών που μπορεί να αποθηκευτεί σε ένα μπλοκ
ευρετηρίου. Με αυτόν τον τρόπο, εξοικονομούμε χώρο στα μεταδεδομένα των μπλοκ ευρετηρίων, καθώς αυτή η πληροφορία είναι κοινή για όλα
τα μπλοκ ευρετηρίου και δεν χρειάζεται να αποθηκεύεται ξεχωριστά σε καθένα από αυτά.
3. Κατά την εισαγωγή μιας εγγραφής στο Β+ δέντρο, πραγματοποιείται πρώτα έλεγχος για την ύπαρξή της. Εάν η εγγραφή δεν υπάρχει ήδη,
τότε προχωρά η διαδικασία εισαγωγής της.
4. Στην παρούσα υλοποίηση της εισαγωγής (insert) σε ένα άδειο Β+ δέντρο, το πρώτο μπλοκ δεδομένων δημιουργείται με id = 1. Αυτό το μπλοκ παραμένει σταθερά
ως το αρχικό μπλοκ δεδομένων,με τις μικρότερες τιμές του δέντρου δηλαδή, διασφαλίζοντας έτσι μια σταθερή δομή από την αρχή της δημιουργίας του δέντρου και
διευκολύνοντας την υλοποίηση της συνάρτησης BP_PrintDatanodes().

Διευκρινίσεις
1. Όλες οι απαιτούμενες συναρτήσεις της εργασίας έχουν υλοποιηθεί και ελεγχθεί, διασφαλίζοντας την ορθή λειτουργία τους.
2. Σε διάφορα σημεία υπάρχει το σχόλιο // PRINT TEST. Έχουμε αφήσει επίτηδες κάποια print tests σε σχόλια προκειμένου να διευκολυνθεί η διόρθωση και
η εξέταση της εργασίας.
3. Δεν έχει γίνει καμία αλλαγή στην bp_file.h, όπως ακριβώς ζητείται.
4. Έχει γίνει μια μικρή προσθήκη στο Makefile για λόγους ευκολίας και εξοικονόμησης χρόνου και αναλύεται στη συνέχεια του readme.
5. Στο αρχείο bp_file.c έχει προστεθεί η συνάρτηση void BP_PrintDatanodes(int file_desc, BPLUS_INFO *bplus_info), η οποία λαμβάνει ως ορίσματα ένα
αρχείο B+ δέντρου και την αντίστοιχη δομή BPLUS_INFO. Η συνάρτηση αυτή εκτυπώνει τα περιεχόμενα των μπλοκ δεδομένων του δέντρου. Ο λόγος της
υλοποίησής της είναι η διευκόλυνση κατά τη διαδικασία διόρθωσης και εξέτασης της εργασίας, παρέχοντας μια ξεκάθαρη εικόνα της δομής και των
δεδομένων που περιέχει το B+ δέντρο.

Ενδιαφέροντα στοιχεία για την εργασία!
1. Το πρόγραμμα υποβλήθηκε σε εκτεταμένους ελέγχους για διαρροές μνήμης (memory leaks) με τη χρήση του εργαλείου Valgrind. Οι δοκιμές
επιβεβαίωσαν ότι δεν παρουσιάζονται προβλήματα διαχείρισης μνήμης, διασφαλίζοντας έτσι την αξιοπιστία και την αποδοτικότητα της υλοποίησης.
2. Όπως αποδεικνύεται από τις δοκιμές που εκτελέστηκαν στο αρχείο bp_main_2.c, το πρόγραμμα μπορεί να χειριστεί επιτυχώς έως και
10.000 εγγραφές,ίσως και αρκετές παραπάνω, με τις τιμές των id να φτάνουν έως και 1.000.000. Αυτό υπογραμμίζει τη σωστή
λειτουργία του Β+ δέντρου ακόμα και για δέντρα μεγάλου ύψους (υψηλότερο του 2). Η δομή και οι λειτουργίες του Β+δέντρου διατηρούν
τη συνέπεια και την απόδοσή τους με τον τρόπο που υλοποιήθηκαν, αποδεικνύοντας την αρτιότητα της υλοποίησης.

Πληροφορίες για το Makefile

	Για την δημιουργία του εκτελέσιμου για το B+ δέντρο, τρέξτε την εντολή:
	make bplus1;

	Για να τρέξετε το εκτελέσιμο:
	./build/bplus_main

	Για καθαρισμό μέσω του τροποποιημένου makefile:
	make clean1

	Επιπλέον, να σημειωθεί ότι επειδή έχουμε προσθέσει μία ακόμα main, όπως ζητείται από την
	εκφώνηση έχουν οριστεί και οι εξής αντίστοιχες εντολές:

	make bplus2;
	./build/bplus_main	// Ίδια εντολή με πριν
	make clean2

	Προσοχή! Πρέπει πάντα να γίνεται clean πριν εκτελεστεί κάποια από τις make bplus1; ή make bplus2;

